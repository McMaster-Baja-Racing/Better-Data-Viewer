/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useFrame, useThree } from '@react-three/fiber'
import { Quaternion, Euler, Vector3 } from 'three';
import { GridHelper, AxesHelper, BoxHelper, Mesh, BufferGeometry, BufferAttribute, MeshBasicMaterial, Box3 } from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader'

export function Eevee(props) {

    // TODO: Get data from server and parse it, then run function to replay it

    let data = 
    `timestamp,x,y,z,w
    0,0,0,0,0`

    // Now generate some random data added onto data variable
    for (let i = 0; i < 1000; i++) {
        // Take x, y, z, w values from the last row and add some random values to them
        const lastRow = data.split('\n').slice(-1)[0];
        const lastRowValues = lastRow.split(',');
        const X = parseFloat(lastRowValues[1]) + Math.random() * 0.01;
        const Y = parseFloat(lastRowValues[2]) + Math.random() * 0.01;
        const Z = parseFloat(lastRowValues[3]) + Math.random() * 0.01;
        const W = parseFloat(lastRowValues[4]) + Math.random() * 0.01;
        const newRow = `${parseInt(lastRowValues[0]) + 10},${X},${Y},${Z},${W}`;
        data += `\n${newRow}`;
    }


    // Now make a list of each column, so we should make 5 lists

    // First, split the data into lines
    const lines = data.split('\n');

    // Then, split each line into columns
    const columns = lines.map(line => line.split(','));

    // Then, remove the first column, which is the header
    const columnsWithoutHeader = columns.slice(1);

    // Then, transpose the columns into rows
    const rows = columnsWithoutHeader[0].map((_, colIndex) => columnsWithoutHeader.map(row => row[colIndex]));

    // Then make a list for each column
    const timestamps = rows[0];
    const x = rows[1];
    const y = rows[2];
    const z = rows[3];
    const w = rows[4];

    let startTime, endTime, elapsedTime;

    // Timestamp stuff
    const replayTimestamps = (index = 0) => {
        if (index === 0) {
            startTime = Date.now();
        }
        if (index < timestamps.length) {
            // Print ALL the data in one line
            //console.log(timestamps[index], x[index], y[index], z[index], w[index]);
            // Cast to float and update the quaternion
            updateQuaternion(parseFloat(x[index]), parseFloat(y[index]), parseFloat(z[index]), parseFloat(w[index]));
    
            if (index < timestamps.length - 1) {
                const delay = timestamps[index + 1] - timestamps[index];
                setTimeout(() => replayTimestamps(index + 1), delay);
            } else {
                endTime = Date.now();
                elapsedTime = endTime - startTime;
                console.log("Elapsed time:", elapsedTime, "ms");
                // Then print difference in first and last timestamp
                console.log("Difference in first and last timestamp:", timestamps[timestamps.length - 1] - timestamps[0], "ms");
            }
        }
    }

    const { scene } = useThree();
    const meshRef = useRef();
    const boxHelperRef = useRef();

    // Make a function that takes in quaternion values and updates the mesh's quaternion
    // This is so we can pass in the quaternion values from the server
    const updateQuaternion = (x, y, z, w) => {
        if (meshRef.current) {
            //console.log("Updating quaternion", x, y, z, w)
            //meshRef.current.quaternion.set(x, y, z, w);
            meshRef.current.rotation.set(x, y, z)
        }
    }
    

    useFrame((_, delta) => {
        if (meshRef.current) {
            // Add a random amount of rotation to the object each frame times delta
            // This is so the rotation is smooth and not dependent on the frame rate
            const quaternion = new Quaternion();
            quaternion.setFromAxisAngle(new Vector3(0, 1, 0), Math.random() * delta);
            // meshRef.current.rotation.x += Math.random() * delta;
            // meshRef.current.rotation.y += Math.random() * delta;
            //meshRef.current.rotation.z += Math.random() * delta;
            //meshRef.current.quaternion.multiply(quaternion);
            

            if (boxHelperRef.current) {
                boxHelperRef.current.update();
            }
            
        }
        
    });

    useEffect(() => {
        const loader = new OBJLoader();

        

        loader.load('/Eevee.obj', (object) => {
            // Add the loaded object to the scene
            scene.add(object);
            meshRef.current = object;

            boxHelperRef.current = new BoxHelper(meshRef.current, 0xffff00);
            scene.add(boxHelperRef.current);      
            
            replayTimestamps();
        });

        const gridHelper = new GridHelper(1000, 100);
        gridHelper.position.y = -11;
        scene.add(gridHelper);

        const axesHelper = new AxesHelper(40);
        scene.add(axesHelper);

        // Cleanup on component unmount
        return () => {
            if (boxHelperRef.current) {
                scene.remove(boxHelperRef.current);
            }
            scene.remove(gridHelper);
            scene.remove(axesHelper);
        };
    }, [scene]);

    //replayTimestamps();

    return (
        <group>
        </group>
    );
}