/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useFrame, useThree } from '@react-three/fiber'
import { Quaternion, Euler, Vector3 } from 'three';
import { GridHelper, AxesHelper, BoxHelper, Mesh, BufferGeometry, BufferAttribute, MeshBasicMaterial, Box3 } from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader'

export function Eevee(props) {

    // TODO: Get data from server and parse it, then run function to replay it

    const data = 
    `timestamp,x,y,z,w
    0,0,0,0,0
    1000, 0, 0.1, 0, 0
    2000, 0, 0.2, 0, 0
    3000, 0, 0.3, 0, 0
    4000, 0, 0.4, 0, 0
    5000, 0, 0.5, 0, 0
    6000, 0, 0.6, 0, 0
    7000, 0, 0.7, 0, 0
    8000, 0, 0.8, 0, 0
    9000, 0, 0.9, 0, 0
    10000, 0, 1, 0, 0`

    // Now make a list of each column, so we should make 5 lists

    // First, split the data into lines
    const lines = data.split('\n');

    // Then, split each line into columns
    const columns = lines.map(line => line.split(','));
    console.log("Columns ", columns)

    // Then, remove the first column, which is the header
    const columnsWithoutHeader = columns.slice(1);
    console.log("Columns without header ", columnsWithoutHeader)

    // Then, transpose the columns into rows
    const rows = columnsWithoutHeader[0].map((_, colIndex) => columnsWithoutHeader.map(row => row[colIndex]));
    console.log("Rows ", rows)

    // Then make a list for each column
    const timestamps = rows[0];
    const x = rows[1];
    const y = rows[2];
    const z = rows[3];
    const w = rows[4];

    // And print timestamps
    console.log("Timestamps ", timestamps)

    // Timestamp stuff
    const replayTimestamps = (index = 0) => {
        if (index < timestamps.length) {
            // Print ALL the data in one line
            //console.log(timestamps[index], x[index], y[index], z[index], w[index]);
            // Cast to float and update the quaternion
            updateQuaternion(parseFloat(x[index]), parseFloat(y[index]), parseFloat(z[index]), parseFloat(w[index]));
    
            if (index < timestamps.length - 1) {
                const delay = timestamps[index + 1] - timestamps[index];
                setTimeout(() => replayTimestamps(index + 1), delay);
            }
        }
    }

    const { scene } = useThree();
    const meshRef = useRef();
    const boxHelperRef = useRef();

    // Make a function that takes in quaternion values and updates the mesh's quaternion
    // This is so we can pass in the quaternion values from the server
    const updateQuaternion = (x, y, z, w) => {
        if (meshRef.current) {
            console.log("Updating quaternion", x, y, z, w)
            meshRef.current.quaternion.set(x, y, z, w);
        }
    }
    

    useFrame((_, delta) => {
        if (meshRef.current) {
            // Add a random amount of rotation to the object each frame times delta
            // This is so the rotation is smooth and not dependent on the frame rate
            const quaternion = new Quaternion();
            quaternion.setFromAxisAngle(new Vector3(0, 1, 0), Math.random() * delta);
            // meshRef.current.rotation.x += Math.random() * delta;
            // meshRef.current.rotation.y += Math.random() * delta;
            //meshRef.current.rotation.z += Math.random() * delta;
            //meshRef.current.quaternion.multiply(quaternion);

            if (boxHelperRef.current) {
                boxHelperRef.current.update();
            }
            
        }
        
    });

    useEffect(() => {
        const loader = new OBJLoader();

        loader.load('/Eevee.obj', (object) => {
            // Add the loaded object to the scene
            scene.add(object);
            meshRef.current = object;

            boxHelperRef.current = new BoxHelper(meshRef.current, 0xffff00);
            scene.add(boxHelperRef.current);

            replayTimestamps();
        });

        const gridHelper = new GridHelper(1000, 100);
        gridHelper.position.y = -11;
        scene.add(gridHelper);

        const axesHelper = new AxesHelper(40);
        scene.add(axesHelper);

        // Cleanup on component unmount
        return () => {
            if (boxHelperRef.current) {
                scene.remove(boxHelperRef.current);
            }
            scene.remove(gridHelper);
            scene.remove(axesHelper);
        };
    }, [scene]);

    //replayTimestamps();

    return (
        <group>
        </group>
    );
}