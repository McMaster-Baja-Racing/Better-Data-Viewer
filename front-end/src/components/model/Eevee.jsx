/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
//import { Quaternion, Euler, Vector3 } from 'three';
import { GridHelper, AxesHelper, BoxHelper, Mesh, BufferGeometry, BufferAttribute, MeshBasicMaterial, Box3 } from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
import { ApiUtil } from '@lib/ApiUtils';

export function Eevee(props) {
  let timestamps, x, y, z, w;

  const extractColumn = (data, columnIndex = 1) => {
    return data.map(row => row[columnIndex]);
  };

  const parseCSV = (data) => {
    return data
      .trim()
      .split('\n')
      .slice(1)
      .map(row => row.split(',')); 
  };

  const lineupfunction = () => {
    return Promise.all([
      ApiUtil.getFile('data/IMU QUAT W.csv'),
      ApiUtil.getFile('data/IMU QUAT X.csv'),
      ApiUtil.getFile('data/IMU QUAT Y.csv'),
      ApiUtil.getFile('data/IMU QUAT Z.csv')
    ]).then(([wDataRaw, xDataRaw, yDataRaw, zDataRaw]) => {
      const wData = parseCSV(wDataRaw);
      const xData = parseCSV(xDataRaw);
      const yData = parseCSV(yDataRaw);
      const zData = parseCSV(zDataRaw);

      w = extractColumn(wData);
      x = extractColumn(xData);
      y = extractColumn(yData);
      z = extractColumn(zData);
      timestamps = extractColumn(wData, 0);
    });
  };

  useEffect(() => {
    lineupfunction().then(() => {
      console.log("Data loaded, starting replayTimestamps");
      replayTimestamps();
    });
  }, []);

  let startTime, endTime, elapsedTime;

  // Timestamp stuff
  const replayTimestamps = (index = 0) => {
    console.log('Replaying timestamp', index, x[index], y[index], z[index], w[index]);
    if (index === 0) {
      startTime = Date.now();
    }
    if (index < timestamps.length) {
      // Cast to float and update the quaternion
      updateQuaternion(parseFloat(x[index]), parseFloat(y[index]), parseFloat(z[index]), parseFloat(w[index]));
    
      if (index < timestamps.length - 1) {
        const delay = (timestamps[index + 1] - timestamps[index]);
        setTimeout(() => replayTimestamps(index + 1), delay);
      } else {
        endTime = Date.now();
        elapsedTime = endTime - startTime;
        console.log('Elapsed time:', elapsedTime, 'ms');
        // Then print difference in first and last timestamp
        console.log('Difference in first and last timestamp:', timestamps[timestamps.length - 1] - timestamps[0], 'ms');
      }
    }
  };

  const { scene } = useThree();
  const meshRef = useRef();
  const boxHelperRef = useRef();

  // Make a function that takes in quaternion values and updates the mesh's quaternion
  // This is so we can pass in the quaternion values from the server
  const updateQuaternion = (x, y, z, w) => {
    if (meshRef.current) {
      meshRef.current.quaternion.set(w, x, y, z);
      // x and w and y
      // y x z w is close but inverted
      // z x y w is close but inverted and slanted
      // y w z x is correct I think    and slanted
      // z w y x
      //meshRef.current.rotation.set(x, y, z)
    }
  };
    

  useFrame((_, delta) => {
    if (meshRef.current) {
      // Add a random amount of rotation to the object each frame times delta
      // This is so the rotation is smooth and not dependent on the frame rate
      //const quaternion = new Quaternion();
      //quaternion.setFromAxisAngle(new Vector3(0, 1, 0), Math.random() * delta);
      // meshRef.current.rotation.x += Math.random() * delta;
      // meshRef.current.rotation.y += Math.random() * delta;
      //meshRef.current.rotation.z += Math.random() * delta;
      //meshRef.current.quaternion.multiply(quaternion);

      if (boxHelperRef.current) {
        boxHelperRef.current.update();
      }
    }
        
  });

  useEffect(() => {
    const loader = new OBJLoader();

    loader.load('/Eevee.obj', (object) => {
      // Add the loaded object to the scene
      scene.add(object);
      meshRef.current = object;

      boxHelperRef.current = new BoxHelper(meshRef.current, 0xffff00);
      scene.add(boxHelperRef.current);      
            
      console.log("Loaded Eevee");
    });

    const gridHelper = new GridHelper(1000, 100);
    gridHelper.position.y = -11;
    scene.add(gridHelper);

    const axesHelper = new AxesHelper(40);
    scene.add(axesHelper);

    // Cleanup on component unmount
    return () => {
      if (boxHelperRef.current) {
        scene.remove(boxHelperRef.current);
      }
      scene.remove(gridHelper);
      scene.remove(axesHelper);
    };
  }, [scene]);

  //replayTimestamps();

  return (
    <group>
    </group>
  );
}